-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Equity.Lifecycle.Merger where

import DA.Date (toDateUTC)
import DA.Time (time)
import Daml.Finance.Interface.Asset.Instrument qualified as Instrument (K, Q)
import Daml.Finance.Interface.Common.Types (Observers)
import Daml.Finance.Interface.Common.Util (flattenObservers)
import Daml.Finance.Interface.Equity.Lifecycle.CorporateAction qualified as CorporateAction (I, View(..))
import Daml.Finance.Interface.Lifecycle.Clock qualified as Clock (view)
import Daml.Finance.Interface.Lifecycle.Event qualified as Event (I, View(..))
import Daml.Finance.Interface.Lifecycle.Lifecyclable qualified as Lifecyclable (HasImplementation, I, Lifecycle(..), View(..))
import Daml.Finance.Lifecycle.Effect (Effect(..))

type T = Merger

instance Lifecyclable.HasImplementation T
-- | Exchange of one unit of an instrument for units of another.
template Merger
  with
    offerer : Party
      -- ^ The parties offering the merger.
    executionDate : Date
      -- ^ The merger's execution date.
    mergingInstrument : Instrument.K
      -- ^ The instrument whose units are consumed by the merger.
    emergingQuantity: Instrument.Q
      -- ^ The instrument whose units are delivered.
    id : Text
      -- ^ A textual identifier.
    observers : Observers
      -- ^ Observers.
  where
    signatory offerer
    observer flattenObservers observers

    implements CorporateAction.I where
      asEvent = toInterface @Event.I this
      asLifecyclable = toInterface @Lifecyclable.I this
      view = CorporateAction.View with offerer; effectiveDate = executionDate; id

    implements Lifecyclable.I where
      view = Lifecyclable.View with lifecycler = offerer
      lifecycleImpl Lifecyclable.Lifecycle{ruleName; settler; clockCid} self = do
        currentDate <- toDateUTC . (.clockTime) . Clock.view <$> fetch clockCid
        if currentDate == executionDate
        then do
          effectCid <- toInterfaceContractId <$> create Effect
            with
              provider = offerer
              settler
              targetInstrument = mergingInstrument
              producedInstrument = None
              consumed = []
              produced = [emergingQuantity]
              settlementDate = executionDate
              id
              observers
          pure (self, [effectCid])
        else do
          pure (self, [])

    implements Event.I where
      view = Event.View with eventTime = time executionDate 11 00 00
