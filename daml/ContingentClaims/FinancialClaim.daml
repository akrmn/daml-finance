--
-- Copyright (c) 2021, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

module ContingentClaims.FinancialClaim where

import Prelude hiding (and, or, time, (.))
import ContingentClaims.Claim
import ContingentClaims.Observable qualified as O
import ContingentClaims.Observable (TimeF, PointF, InequalityF, Observable)
import Daml.Control.Recursion
import DA.Date (date, Month)

-- | Helper function to generate a series of fixing dates, e.g. for coupon payments in @cpb@.
-- | This assumes @fixingMonths@ and @fixingDates@ are ordered.
unrollDates : Int -> Int -> [Month] -> Int -> [Date]
unrollDates issueYear maturityYear fixingMonths fixingDay =
  date <$> [issueYear .. maturityYear] <*> fixingMonths <*> [fixingDay]

-- | Observable that is true on the passed time. i.e. identity for the time observable.
at
  : forall f t . (TimeF f t, PointF f t t, InequalityF f t t)
  => t -> f t Bool
at t = O.time O.== (O.pure t)

-- | Forward rate agreement. Scaled by (potentially stochastic) interest rate @r@.
fra : Observable f t => t -> f t Decimal -> Claim f t a -> Claim f t a
fra maturity r payoff = when (at maturity) $ scale r payoff

-- | Zero Coupon Bond.
zcb : Observable f t => t -> Decimal -> ccy -> Claim f t ccy
zcb maturity principal ccy = fra maturity (O.pure principal) (one ccy)

-- | A floating rate bond. The first two arguments are @Observables@.
floating : Observable f t => f t Decimal -> f t Decimal -> ccy -> [t] -> Claim f t ccy
floating principal coupon asset = apo \case
     [maturity] -> Left (fra maturity coupon (one asset)) `AndF` Left (fra maturity principal (one asset))
     (t :: ts) -> Left (fra t coupon (one asset)) `AndF` Right ts
     [] -> ZeroF

-- | A (fixed rate) coupon paying bond
cpb : Observable f t => Decimal -> Decimal -> ccy -> [t] -> Claim f t ccy
cpb principal coupon = floating (O.pure principal) (O.pure coupon)

-- | European option on the passed claim.
european
  : forall f t a . (TimeF f t, PointF f t t, InequalityF f t t)
  => t -> Claim f t a -> Claim f t a
european t u = when (at t) (u `or` Zero)

-- | Bermudan option on the passed claim.
bermudan
  : forall f t a . (TimeF f t, PointF f t t, InequalityF f t t)
  => Claim f t a -> [t] -> Claim f t a
bermudan u = apo \case
  (t :: ts) -> Left (european t u) `OrF` Right ts
  [] -> ZeroF

-- | Asset swap on specific fixing dates @ts@. 
-- | The owner has the rights of the first claim and the obligations of the second.
swap : forall f t a . ([t] -> Claim f t a) -> ([t] -> Claim f t a) -> [t] -> Claim f t a
swap c c' ts = c ts `and` give (c' ts)

{-
between
  : forall f t a . (TimeF f t, PointF f t t, InequalityF (f t) t, LogicF (f t))
  => t -> t -> f t Bool
between t t' = liftA2 (&&) (O.time O.>= O.pure t) O.&&  (O.time O.<= O.pure t')

american
  : forall f t a . (Ord t, Category f, Applicative (f t))
  => t -> t -> Claim f t a -> Claim f t a
american t t' u = anytime (between t t') u

-}
